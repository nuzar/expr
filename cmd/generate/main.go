package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
)

func main() {
	_ = defineAst(".", "Expr", []string{
		"Binary   : left Expr, operator *Token, right Expr",
		"Call     : callee Expr, paren *Token, arguments []Expr",
		"Grouping : expression Expr",
		"Literal  : value interface{}, rtype reflect.Kind",
		"Logical  : left Expr, operator *Token, right Expr",
		"Unary    : operator *Token, right Expr",
		"Array    : bracket *Token, items []Expr",
		"Variable : name *Token",
	})

	// defineAst(".", "Stmt", []string{
	// 	"Expression : expression Expr",
	// 	"Print      : expression Expr",
	// })
}

func defineAst(outputDir, basename string, types []string) error {
	path := outputDir + "/" + strings.ToLower(basename) + "_def.go"

	var buffer = new(bytes.Buffer)
	buffer.WriteString("// Code generated by cmd. DO NOT EDIT.\n\n")
	buffer.WriteString("package expr\n\n")
	buffer.WriteString("import \"reflect\"\n\n")

	buffer.WriteString(fmt.Sprintf("type %s interface {\n", basename))
	// visitor pattern
	// 生成一个打印对象的visitor，主要用于调试
	buffer.WriteString(fmt.Sprintf("	AcceptStr(visitor %sVisitorStr) string\n", basename))
	// 这个是用于执行语句的visitor。没有泛型，定义不了通用的visitor...
	buffer.WriteString(fmt.Sprintf("	AcceptObj(visitor %sVisitorObj) (interface{}, error)\n", basename))
	buffer.WriteString("}\n\n")

	defineVisitor(buffer, basename, types)

	// The AST types
	for _, typ := range types {
		splits := strings.Split(typ, ":")
		typename := strings.TrimSpace(splits[0])
		fields := strings.TrimSpace(splits[1])
		defineType(buffer, basename, typename, fields)
	}

	if err := ioutil.WriteFile(path, buffer.Bytes(), 0o666); err != nil {
		return fmt.Errorf("write file %s failed: %w", path, err)
	}

	return nil
}

type Field struct{ Name, Type string }

func defineType(builder *bytes.Buffer, basename, typename, fieldlist string) {
	fields := make([]Field, 0)
	// arg1 Arg1Type, arg2 Arg2Type
	splits := strings.Split(fieldlist, ", ")
	for _, field := range splits {
		// arg1 Arg1Type
		fieldsplits := strings.Split(field, " ")
		filedname, fieldtype := fieldsplits[0], fieldsplits[1]
		fields = append(fields, Field{
			Name: filedname,
			Type: fieldtype,
		})
	}

	fulltypename := basename + typename

	builder.WriteString(fmt.Sprintf("type %s struct {\n", fulltypename))
	for _, f := range fields {
		builder.WriteString(fmt.Sprintf("	%s %s\n", f.Name, f.Type))
	}
	builder.WriteString("}\n\n")

	builder.WriteString(fmt.Sprintf("func New%s(", fulltypename))
	for i, f := range fields {
		if i != 0 {
			builder.WriteString(", ")
		}
		builder.WriteString(fmt.Sprintf("%s %s", f.Name, f.Type))
	}
	builder.WriteString(fmt.Sprintf(") %s {\n", basename))
	builder.WriteString(fmt.Sprintf("	t := &%s{}\n", fulltypename))
	for _, f := range fields {
		builder.WriteString(fmt.Sprintf("	t.%s = %s\n", f.Name, f.Name))
	}
	builder.WriteString("	return t\n")
	builder.WriteString("}\n\n")

	builder.WriteString(
		fmt.Sprintf("func (e *%s) AcceptStr(visitor %sVisitorStr) string {\n", fulltypename, basename))
	builder.WriteString(
		fmt.Sprintf("	return visitor.Visit%sStr(e)\n", fulltypename))
	builder.WriteString("}\n\n")

	builder.WriteString(
		fmt.Sprintf("func (e *%s) AcceptObj(visitor %sVisitorObj) (interface{}, error) {\n", fulltypename, basename))
	builder.WriteString(
		fmt.Sprintf("	return visitor.Visit%sObj(e)\n", fulltypename))
	builder.WriteString("}\n\n")
}

func defineVisitor(buffer *bytes.Buffer, basename string, types []string) {
	buffer.WriteString(fmt.Sprintf("type %sVisitorStr interface{\n", basename))
	for _, typ := range types {
		typename := strings.TrimSpace(strings.Split(typ, ":")[0])
		fulltypename := basename + typename
		buffer.WriteString(fmt.Sprintf("	Visit%sStr(%s *%s) string\n",
			fulltypename, strings.ToLower(typename), fulltypename))
	}
	buffer.WriteString("}\n\n")

	buffer.WriteString(fmt.Sprintf("type %sVisitorObj interface{\n", basename))
	for _, typ := range types {
		typename := strings.TrimSpace(strings.Split(typ, ":")[0])
		fulltypename := basename + typename
		buffer.WriteString(fmt.Sprintf("	Visit%sObj(%s *%s) (interface{}, error)\n",
			fulltypename, strings.ToLower(typename), fulltypename))
	}
	buffer.WriteString("}\n\n")
}
